# 整理一些八股文

## a

### b

#### 计算机体系结构

冯诺伊曼架构（Von Neumann Architecture）是一种计算机体系结构模型，由约翰·冯·诺伊
曼在 1945 年提出。

它的主要特点包括：

- 存储程序概念：程序和数据存储在同一个存储器中，计算机可以通过读取存储器中的指令
  来执行程序。
- 中央处理单元（CPU）：包括算术逻辑单元（ALU）和控制单元（CU），负责执行指令和处
  理数据。
- 存储器：用于存储程序和数据。
- 输入/输出设备：用于与外部环境进行交互。
- 单一的总线系统：用于在 CPU、存储器和 I/O 设备之间传输数据。

冯诺伊曼架构的工作流程通常包括以下几个步骤：

- 取指令：从存储器中读取下一条指令。
- 指令译码：将指令译码为 CPU 可以执行的操作。
- 执行指令：根据指令执行相应的操作，如算术运算、数据传输等。
- 存储结果：将结果存储到存储器或寄存器中。
- 更新程序计数器：指向下一条指令的地址。

这种架构的优点是设计简单、易于实现，但也存在一些缺点，如“冯诺伊曼瓶颈”，即由于程
序和数据共享同一条总线，导致数据传输速率受限。

#### C/C++

1. **`C` 和 `CPP` 区别**
   1. **语言特性**：
      - `C` 是一种过程式编程语言，主要用于系统编程和嵌入式系统。
      - `C++` 是 `C` 的扩展，支持面向对象编程、泛型编程和元编程。
   2. **标准库**：
      - `C` 标准库较小，主要包括基本的输入输出、字符串处理和数学函数。
      - `C++` 标准库更大，包含了 `STL`（标准模板库），提供了丰富的数据结构和算法
        。
   3. **内存管理**：
      - `C` 主要使用 `malloc` 和 `free` 进行手动内存管理。
      - `C++` 提供了 `new` 和 `delete` 操作符，并支持智能指针（如
        `unique_ptr`、`shared_ptr` 和 `weak_ptr`）进行自动内存管理。
   4. **函数和方法**：
      - `C` 中只有函数，没有方法。
      - `C++` 中有成员函数（方法），可以定义在类中。
   5. **命名空间**：
      - `C` 没有命名空间，所有标识符在全局范围内。
      - `C++` 引入了命名空间，避免命名冲突。
   6. **异常处理**：
      - `C` 通过返回值和错误码处理异常。
      - `C++` 提供了 `try`、`catch` 和 `throw` 关键字进行异常处理。
   7. **类型检查**：
      - `C` 的类型检查较弱，允许隐式类型转换。
      - `C++` 的类型检查更严格，支持强制类型转换。
   8. **面向对象编程**：
      - `C` 不支持面向对象编程。
      - `C++` 支持类、继承、多态和封装等面向对象编程特性。
2. **智能指针**
   - `unique_ptr`: 独占所有权的智能指针，不能被复制，只能被移动，用于管理动态分配
     的资源
   - `share_ptr`: 共享所有权的智能指针，可以被多个 `shared_ptr` 实例共享，使用引用计
     数来管理资源
   - `weak_ptr`: 弱引用智能指针，不影响 `shared_ptr` 的引用计数，通常用于解决循环引
     用问题
3. **虚函数**

   - 虚函数是指在基类中使用 `virtual` 关键字声明的函数，允许在派生类中重写。
   - 虚函数的主要目的是实现多态性，使得基类指针或引用可以调用派生类的实现。

   基类定义虚函数：

   - 使用 `virtual` 关键字声明虚函数。
   - 可以提供默认实现，也可以是纯虚函数（使用 = 0 表示）。

   派生类重写虚函数：

   - 使用 `override` 关键字明确表示重写基类的虚函数。
   - 使用基类指针或引用调用虚函数：
   - 通过基类指针或引用调用虚函数，实际调用的是派生类的实现。

虚函数表 (`vtable`) 是一个由编译器生成的数据结构，用于支持 C++ 中的虚函数和多态性
。每个包含虚函数的类都有一个虚函数表，表中存储了该类的虚函数指针。每个对象包含一
个指向其所属类的虚函数表的指针。

##### 虚函数表的工作原理

1. **类定义**：当一个类定义了虚函数时，编译器会为该类生成一个虚函数表。
2. **虚函数表指针**：每个对象在其内存布局中包含一个指向虚函数表的指针。
3. **函数调用**：当通过基类指针或引用调用虚函数时，程序会通过虚函数表指针查找实
   际要调用的函数。

##### 虚函数表示例代码

```cpp
#include <iostream>

class Base {
public:
    virtual void show() {
        std::cout << "Base class show function" << std::endl;
    }
    virtual ~Base() = default;
};

class Derived : public Base {
public:
    void show() override {
        std::cout << "Derived class show function" << std::endl;
    }
};

int main() {
    Base* basePtr = new Derived();
    basePtr->show(); // 调用的是派生类的实现
    delete basePtr;
    return 0;
}
```

在这个示例中，`Base` 类和 `Derived` 类都有一个虚函数 `show`。当通过基类指针
`basePtr` 调用 `show` 函数时，程序会通过虚函数表查找并调用 `Derived` 类的实现。

1. 编译器将虚函数的名字转换成函数指针表中对应的索引值
2. 每个虚函数类都有自己的虚函数表用于辨识虚函数
3. 空间开销
   1. 如果类包含虚函数, 则该类每个对象都需要一个额外的指针
   2. 每个类都需要一个虚函数表

#### i++ 和 ++i

1. 区别

   `++i` will increment the value of `i`, and then return the incremented value.

   ```cpp
   i = 1;
   j = ++i;
   (i is 2, j is 2)
   ```

   `i++` will increment the value of `i`, but return the original value that i
   held before being incremented.

   ```cpp
   i = 1;
   j = i++;
   (i is 2, j is 1)
   ```

2. 性能优化

   - 简单类型编译器优化为同样的汇编，无明显区别

   There's a couple of comments regarding the efficiency of ++i and i++. In any
   non-student-project compiler, there will be no performance difference.

   - 复杂对象取决于编译器，性能未知

   It's different for a C++ object, since operator++() is a function and the
   compiler can't know to optimize away the creation of a temporary object to
   hold the intermediate value.

#### 计算机图形

1. **Flat**

   每个三角形的法线计算着色效果。着色计算只执行一次，整个三角形都采用计算结果的
   颜色。

2. **Gouraud**

   每个三角形计算三个光照，同时针对三角形中每个点做线性插值

3. **Phong**

   包括环境光照、漫反射光照和镜面反射光照。在计算镜面反射光照时，Phong 模型使用
   观察者（视点）方向和反射光方向之间的角度。镜面高光的亮度取决于这两个方向的角
   度差的余弦值的某个高次幂，这个幂通常称为镜面反射指数（specular exponent），它
   决定了高光的大小和模糊程度。 Phong 模型直接计算光线反射向量，然后与视线向量的
   夹角决定高光的强度，

4. **Blinn Phong**

   在 Blinn-Phong 模型中，镜面高光的计算基于半向量和表面法线向量之间的角度，而不
   是使用反射向量和视线向量。这种方法简化了计算过程，并且在某些情况下可以提供更
   加符合物理规律的视觉效果，特别是在模拟细小高光和柔和边缘时。

5. **PBR**

#### Vulkan

#### GPU 相关

1. Early-Z

#### 计算机网络

##### 计算机网络的层次结构通常分为以下几个层次

- 物理层：负责传输原始的比特流，定义硬件设备的电气特性、物理连接和数据传输速率等
  。
- 数据链路层：负责将物理层传输的比特流组装成帧，并提供错误检测和纠正功能。
- 网络层：负责数据包的路由选择和转发，确保数据从源端到达目的端。
- 传输层：提供端到端的通信服务，确保数据可靠传输，常见协议有`TCP`和`UDP`。
- 会话层：管理会话和连接，负责建立、维护和终止通信会话。
- 表示层：负责数据的格式化、加密和解密，确保数据在不同系统之间的兼容性。
- 应用层：提供用户直接使用的网络服务，如`HTTP`、`FTP`、`SMTP`等。

这些层次共同工作，确保数据能够在不同设备和网络之间可靠传输。

##### 三次握手四次挥手

```txt
三次握手 (建立连接)

客户端发送 SYN 包给服务器，主动打开请求连接。
    SYN = 1
    seq = x

服务器被动打开并发送 SYN-ACK 包回复客户端。
    SYN = 1
    ACK = 1
    seq = y
    ack = x + 1

客户端发送 ACK 包确认。
    ACK = 1
    seq = x + 1
    ack = y + 1


四次挥手 (终止连接)

客户端发送 FIN 包给服务器，主动请求关闭连接。
    Fin = 1
    seq = u

服务器发送 ACK 包确认， 并通知应用进程。
    ACK = 1
    seq = v
    ack = u + 1

服务器发送 FIN 包请求，被动关闭。
    FIN = 1
    ACK = 1
    seq = w
    ack = u + 1

客户端发送 ACK 包确认，等待 2MSL 关闭
    ACK = 1
    sqe = u + 1
    ack = w + 1
```

##### TCP 拥塞控制

是为了防止网络拥塞而设计的一组机制，主要包括以下几个算法：

1. **慢启动 (Slow Start)**：

   初始时，拥塞窗口 (cwnd) 设置为 1。每次收到一个 ACK，cwnd 加倍。直到达到慢启动
   阈值 (ssthresh) 后，进入拥塞避免阶段。

2. **拥塞避免 (Congestion Avoidance)**：

   当 cwnd 达到 ssthresh 时，每次收到一个 ACK，cwnd 增加 1。逐步增加发送速率，避
   免网络拥塞。

3. **快速重传 (Fast Retransmit)**：

   当收到三个重复的 ACK 时，立即重传丢失的数据包，而不等待超时。

4. **快速恢复 (Fast Recovery)**：

   在快速重传后，不进入慢启动，而是将 ssthresh 设置为 cwnd 的一半，并将 cwnd 设
   置为 ssthresh 加上 3。继续进行拥塞避免。

这些算法共同工作，确保 TCP 连接在不同网络条件下能够高效、可靠地传输数据
